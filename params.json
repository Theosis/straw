{"name":"Straw","tagline":"Realtime processing framework for Node.js","body":"# Straw\r\n\r\nRealtime processing framework for Node.js\r\n\r\nVersion 0.2.0\r\n\r\n[![Build Status](https://travis-ci.org/simonswain/straw.png)](https://travis-ci.org/simonswain/straw)\r\n\r\nStraw lets you run a Topology of worker Nodes that consume, process,\r\ngenerate and emit messages, connected together with message passing\r\nPipes.\r\n\r\nEach Node is run in it's own process. Messages are passed in and out\r\nof Nodes as JSON.\r\n\r\nA simple Topology might look like this\r\n\r\n```\r\n  ping --> count --> print\r\n```\r\n\r\nNodes can have multiple inputs and outputs. Messages can be passed out\r\nto a connected pipe via a Node's default output or any number of\r\narbitrarily named outputs.\r\n\r\nMessages are queued between Nodes, with each Node processing one\r\nmessage at a time.\r\n\r\nRedis is used for message passing but Nodes are shielded from\r\nimplementation. All you need to write is the processing code, extend a\r\nhandler for receiving messages and call a method to send.\r\n\r\nThere is nothing preventing a node receiving or sending outside the\r\nTopology, e.g. write to a database, fetch or listen for network data.\r\n\r\nA library method is provided to inject or receive messages from\r\noutside the Topology so you can play nicely with existing\r\ninfrastructure, for example having data pipe in to an Express server\r\nfor publishing out via socket.io.\r\n\r\nStatsD support is included out of the box, giving you visibility of\r\nactivity across a topology.\r\n\r\n## Installing\r\n\r\n    $ npm install straw \r\n\r\n## Hacking\r\n\r\n    $ git clone git@github.com:simonswain/straw.git\r\n    $ cd straw\r\n    $ npm install -d\r\n\r\nRun the tests (`npm install -g grunt-cli` first):\r\n\r\n    $ npm test\r\n\r\nRun some examples\r\n\r\n    $ node examples/ping-count-print.js\r\n   \r\n## Usage\r\n\r\nBy convention you create your Nodes in a folder called `nodes`, and\r\ninstantiate a Topology, passing in an object describing how the nodes\r\nare to be piped together.\r\n\r\nThis example has a Node that generates timestamps once a second, with\r\nit's output going to another that counts the cumulative number of\r\npings.\r\n\r\n\r\n```javascript\r\nvar straw = require('straw');\r\nvar topo = new straw.topology({\r\n  'ping':{\r\n    'node': __dirname + '/../examples/nodes/ping',\r\n    'output':'ping-out'\r\n  },\r\n  'count':{\r\n    'node': __dirname + '/../examples/nodes/count',\r\n    'input':'ping-out',\r\n    'output':'count-out'\r\n  },\r\n  'print':{\r\n    'node': __dirname + '/../examples/nodes/print',\r\n    'input':'count-out'\r\n  }\r\n});\r\n```\r\n\r\nNodes extends the prototype Node and override only the methods needed\r\nto do their job.\r\n\r\n```javascript\r\nvar straw = require('straw')\r\nmodule.exports = straw.node.extend({\r\n  title: 'Ping',\r\n  timer: null,\r\n  opts: {interval: 1000},\r\n  initialize: function(opts, done){\r\n    this.opts.interval = opts && opts.interval || 1000;\r\n    process.nextTick(done);\r\n  },\r\n  run: function(done) {\r\n    var self = this;\r\n    var fn = function() {\r\n      self.ping();\r\n    };\r\n    this.timer = setInterval(fn, this.opts.interval);\r\n    done(false);\r\n  },\r\n  stop: function(done) {\r\n    clearInterval(this.timer);\r\n    done(false);\r\n  },\r\n  ping: function() {\r\n    this.output({'ping': new Date().getTime()});\r\n  }\r\n});\r\n```\r\n\r\n`process()` is called every time a message received at the Node's\r\ninput.\r\n\r\nYour code needs to call `output()` whenever you have a message to send\r\nout from the node, and must excute the `done` callback.\r\n\r\n```javascript\r\nvar straw = require('straw');\r\nmodule.exports = straw.node.extend({\r\n  title: 'Count',\r\n  total: 0,\r\n  process: function(msg, done) {      \r\n    this.total ++;\r\n    this.output({count: this.total}, done);\r\n  }\r\n});\r\n```\r\n\r\nCalling `console.log` from within a node will output timestamped\r\nmessages to the shell, showing you which Node they came from.\r\n\r\nRun the topology like this:\r\n\r\n\r\n```\r\n$ node examples/ping-count-print.js \r\n2013-07-20 10:59:17 INIT     6988 print\r\n2013-07-20 10:59:17 STARTED  6988 print\r\n2013-07-20 10:59:17 INIT     6985 ping\r\n2013-07-20 10:59:17 STARTED  6985 ping\r\n2013-07-20 10:59:17 INIT     6987 count\r\n2013-07-20 10:59:17 STARTED  6987 count\r\n2013-07-20 10:59:17 TOPOLOGY STARTED\r\n2013-07-20 10:59:18 STDOUT   print                {\"count\":1}\r\n2013-07-20 10:59:19 STDOUT   print                {\"count\":2}\r\n2013-07-20 10:59:20 STDOUT   print                {\"count\":3}\r\n```\r\n\r\nPress `^C` to stop.\r\n\r\n    \r\n(Watching files is disabled for now until I can resolve `Error watch\r\nEMFILE` being thrown. You can re-enable by changing `this.watch =\r\nfalse;` to true at the top of lib/runner.js)\r\n\r\nIf you make any changes to a node file it's process will be terminated\r\nand respawned. This is really handy in development. try running the\r\nping-count-print example, edit `examples/nodes/print/index.js` (just\r\nadd a space somewhere) then save it. You will see output in the log\r\nletting you know it's been stopped and restarted.\r\n\r\nThe examples are stored in a folder named after each node, it's fine\r\nmaking a folder called nodes and naming each node's file directly.\r\nJust make sure you use an absolute path, e.g. `__dirname +\r\n'./path/to/nodes/some-node.js'` in your Topology definition.\r\n\r\n```\r\nnodes/my-node.js\r\nnodes/some-node.js\r\n```\r\n    \r\n## Topology\r\n\r\nEach Node must be defined in the Topology like so:\r\n\r\n```javascript\r\n'<your-key>':{\r\n    'node': '<absolute-path-to-node>',\r\n    'input':'in-pipe-name',\r\n    'output':'out-pipe-name',\r\n    'outputs': {\r\n        ['named-output', 'another-named-output']\r\n        },\r\n    'log': '<file-to-log-output-to>'\r\n}\r\n```\r\n\r\nTo specify the location of a node relative to your topology code, use\r\n`__dirname + '/where/is/my/node.js'`.\r\n\r\n`input` and `output` can either be the key of a single pipe, or an\r\narray of pipe keys. This lets you aggregate input and branch output.\r\nIf the output field is an array, the same message will be sent to each\r\nof them.\r\n\r\n```javascript\r\n// single\r\ninput: 'some-pipe'\r\noutput: 'that-pipe'\r\n\r\n// multiple\r\ninput: ['this-pipe','that-pipe']\r\noutput: ['this-pipe','that-pipe']\r\n```\r\n\r\n`log` and `outputs` are optional. All other fields are required.\r\n\r\n`STDOUT` from the node (e.g. `console.log`) will be captured to the log.\r\n\r\nYou must define named outputs in your Topology before using them in\r\nthe node.\r\n\r\nAny other fields will be passed in to the Node as options for it to\r\nuse as it sees fit.\r\n\r\nYou can optionally place a callback function as the last argument to\r\n`straw.topology` that will be called once all the Nodes are up and\r\nrunning.\r\n\r\ntopology#destroy will take down all the nodes and pipes used in the\r\nTopology.\r\n\r\n### Options\r\n\r\nYou can pass options in to the Topology that will be passed in to all\r\nnode runners. These let you set the Redis host and enable StatsD. You\r\ncan add your own keys to `redis`, which is handy for things like\r\nadding prefixes to your keys in to the Node.\r\n\r\n```javascript\r\nvar straw = require('straw');\r\nvar topo = new straw.topology({\r\n  'ping':{\r\n    'node': __dirname + '/nodes/ping',\r\n    'output':'ping-out'\r\n  },\r\n}, {\r\n  pidsfile: __dirname + '/../straw-pids.js',\r\n  redis: {\r\n    host: '127.0.0.1',\r\n    port: 6379\r\n  },\r\n  statsd: {\r\n    prefix: 'straw',\r\n    host: '127.0.0.1',\r\n    port: 8125\r\n  }\r\n});\r\n```\r\n\r\nIf no options or redis are provided, the default shown above will be\r\nused.\r\n\r\nIf pidsfile is provided, when Straw starts a Topology it will write the\r\nPIDs of the nodes to this file, and on next start will attempt to kill\r\nthose PIDs. This experimental feature is to try and kill Nodes left\r\nstill running after a crash.\r\n\r\nIf StatsD is provided, all node inputs and outputs (summed, and split\r\nout by key) will be counted with `node-statsd.increment()`, using the\r\nnode's key as the identifier.\r\n\r\nIf you provide a prefix, it will be prepended to the nodes's key so\r\nyou can namespace your stats across multiple Topologies.\r\n\r\n## Nodes\r\n\r\nThese methods can/must be overridden depending on the required\r\nfunctionality of your node;\r\n\r\nThe `done` calls are required.\r\n\r\nIn the `#initialize` method, you must use `process.nextTick(done)`\r\n\r\n```javascript\r\nmodule.exports = straw.node.extend({\r\n    title: 'Human readable name',\r\n    initialize: function(opts, done) {\r\n        // process incoming options from the topology definition,\r\n        // set up anything you need (e.g. database connection)\r\n        // and when all finished run the done callback.\r\n        process.nextTick(done);\r\n    },\r\n    process: function(msg, done) {\r\n        // process an incoming message. msg will be JSON.\r\n\r\n        // this example just passes thru msg. normally you would do\r\n        // some work on it here.\r\n        // ...\r\n        // and send it via the default output\r\n        this.output(msg);\r\n\r\n        // or send it via a named output. The name must be configured\r\n        // in your topology\r\n        this.output('named-output', msg);\r\n        done()\r\n    },\r\n    run: function(done) {\r\n        // start some background processing here e.g. fetch or\r\n        // generate data\r\n        done();\r\n    },\r\n    stop: function(done) {\r\n        // stop background processing. will be called when\r\n        // terminating.\r\n        done();\r\n    }\r\n});\r\n```\r\n\r\n## Pipes\r\n\r\nPipes are implemented using Redis lists - `lpush` and `brpop`. \r\n\r\nWhen more than one Node is connected to a given output, only one will\r\nreceive each message. This lets you easily load-balance output from a\r\nnode.\r\n\r\nWhen a node finished processing a message it must call the `done`\r\ncallback. This signals it's ready for the next message.\r\n\r\nIf you want a message to go to several nodes, create multiple outputs\r\nand connect one node to each.\r\n\r\n`examples/busy-worker.js` and `examples/busy-workers.js` show this in\r\noperation.\r\n\r\nIf no purge flag is set or if set to true, pipes are cleared when the\r\nTopology is started so un-processed messages from previous runs are\r\nnot consumed. To retain them across restarts set purge to false.\r\n\r\n### Tap In/Out\r\n\r\nYou can connect to a Topology from existing code. These Tap methods\r\nbehave the same as those you would write inside your nodes.\r\n\r\n```javascript\r\nvar tap = new straw.tap({\r\n  'input':'from-topology-pipe,\r\n  'output':'to-topology-pipe\r\n});\r\n\r\ntap.send(msg);\r\n\r\ntap..on('message', function() {\r\n  // ...\r\n});\r\n\r\n```\r\n\r\n### Stats\r\n\r\nNodes accumulate counts of messages emitted. You can use the count\r\nmethod to count arbitrary values also.\r\n\r\n```javascript\r\nthis.count('some-key');\r\nthis.count('some-key', howmany);\r\n\r\nthis.counts(); // {\"messages\": 5, \"some-key\":4}\r\nthis.counts(\"some-key\"); // 4\r\n```\r\n\r\n## Installing as a service\r\n\r\nOnce you have your Topology tested and working you'll probably want to\r\ninstall it as a service.\r\n\r\nPlace this somewhere like `/etc/init/myapp.conf`. The path to your\r\nnode binary may be different, particularly if you are using nvm.\r\n\r\n```\r\n#!upstart\r\ndescription \"My Topology\"\r\nauthor      \"simon\"\r\n\r\nstart on startup\r\nstop on shutdown\r\n\r\nscript\r\n    export HOME=\"/path/to/app\"\r\n    echo $$ > /var/run/my-app.pid\r\n    exec sudo -u sysop /usr/bin/node /path/to/app/myapp.js >> /var/log/app/myapp.log 2>&1\r\nend script\r\n```\r\n\r\n     $ sudo service myapp start\r\n\r\n## Thanks\r\n\r\nStraw takes some inspiration from\r\n[Storm](https://github.com/nathanmarz/storm) and\r\n[Max/MSP](http://cycling74.com). It uses some code and concepts from\r\n[Backbone](http://backbonejs.org) for the node definitions and event\r\nhandling.\r\n\r\n## Release History\r\n\r\n* 14/11/2012 0.1.0 Initial release\r\n* 15/11/2012 0.1.1 StatsD support \r\n* 22/11/2012 0.1.2 Round-robin pipes\r\n* 23/01/2013 0.1.3 Taps\r\n* 31/01/2013 0.1.5 Cleaning up callback usage\r\n* 08/04/2013 0.1.6 Added pidsfile support\r\n* 19/07/2013 0.2.0 Removed Pubsub. Enforced callbacks.\r\n\r\n## License\r\nCopyright (c) 2012-2013 Simon Swain  \r\nLicensed under the MIT license.\r\n","google":"UA-42718447-1","note":"Don't delete this file! It's used internally to help with page regeneration."}