<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Straw by simonswain</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Straw</h1>
          <h2>Realtime processing framework for Node.js</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/simonswain/straw/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/simonswain/straw/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/simonswain/straw" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a name="straw" class="anchor" href="#straw"><span class="octicon octicon-link"></span></a>Straw</h1>

<p>Realtime processing framework for Node.js</p>

<p>Version 0.2.0</p>

<p><a href="https://travis-ci.org/simonswain/straw"><img src="https://travis-ci.org/simonswain/straw.png" alt="Build Status"></a></p>

<p>Straw lets you run a Topology of worker Nodes that consume, process,
generate and emit messages, connected together with message passing
Pipes.</p>

<p>Each Node is run in it's own process. Messages are passed in and out
of Nodes as JSON.</p>

<p>A simple Topology might look like this</p>

<pre><code>  ping --&gt; count --&gt; print
</code></pre>

<p>Nodes can have multiple inputs and outputs. Messages can be passed out
to a connected pipe via a Node's default output or any number of
arbitrarily named outputs.</p>

<p>Messages are queued between Nodes, with each Node processing one
message at a time.</p>

<p>Redis is used for message passing but Nodes are shielded from
implementation. All you need to write is the processing code, extend a
handler for receiving messages and call a method to send.</p>

<p>There is nothing preventing a node receiving or sending outside the
Topology, e.g. write to a database, fetch or listen for network data.</p>

<p>A library method is provided to inject or receive messages from
outside the Topology so you can play nicely with existing
infrastructure, for example having data pipe in to an Express server
for publishing out via socket.io.</p>

<p>StatsD support is included out of the box, giving you visibility of
activity across a topology.</p>

<h2>
<a name="installing" class="anchor" href="#installing"><span class="octicon octicon-link"></span></a>Installing</h2>

<pre><code>$ npm install straw 
</code></pre>

<h2>
<a name="hacking" class="anchor" href="#hacking"><span class="octicon octicon-link"></span></a>Hacking</h2>

<pre><code>$ git clone git@github.com:simonswain/straw.git
$ cd straw
$ npm install -d
</code></pre>

<p>Run the tests (<code>npm install -g grunt-cli</code> first):</p>

<pre><code>$ npm test
</code></pre>

<p>Run some examples</p>

<pre><code>$ node examples/ping-count-print.js
</code></pre>

<h2>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h2>

<p>By convention you create your Nodes in a folder called <code>nodes</code>, and
instantiate a Topology, passing in an object describing how the nodes
are to be piped together.</p>

<p>This example has a Node that generates timestamps once a second, with
it's output going to another that counts the cumulative number of
pings.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">straw</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'straw'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">topo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">straw</span><span class="p">.</span><span class="nx">topology</span><span class="p">({</span>
  <span class="s1">'ping'</span><span class="o">:</span><span class="p">{</span>
    <span class="s1">'node'</span><span class="o">:</span> <span class="nx">__dirname</span> <span class="o">+</span> <span class="s1">'/../examples/nodes/ping'</span><span class="p">,</span>
    <span class="s1">'output'</span><span class="o">:</span><span class="s1">'ping-out'</span>
  <span class="p">},</span>
  <span class="s1">'count'</span><span class="o">:</span><span class="p">{</span>
    <span class="s1">'node'</span><span class="o">:</span> <span class="nx">__dirname</span> <span class="o">+</span> <span class="s1">'/../examples/nodes/count'</span><span class="p">,</span>
    <span class="s1">'input'</span><span class="o">:</span><span class="s1">'ping-out'</span><span class="p">,</span>
    <span class="s1">'output'</span><span class="o">:</span><span class="s1">'count-out'</span>
  <span class="p">},</span>
  <span class="s1">'print'</span><span class="o">:</span><span class="p">{</span>
    <span class="s1">'node'</span><span class="o">:</span> <span class="nx">__dirname</span> <span class="o">+</span> <span class="s1">'/../examples/nodes/print'</span><span class="p">,</span>
    <span class="s1">'input'</span><span class="o">:</span><span class="s1">'count-out'</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>

<p>Nodes extends the prototype Node and override only the methods needed
to do their job.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">straw</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'straw'</span><span class="p">)</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">straw</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">title</span><span class="o">:</span> <span class="s1">'Ping'</span><span class="p">,</span>
  <span class="nx">timer</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">opts</span><span class="o">:</span> <span class="p">{</span><span class="nx">interval</span><span class="o">:</span> <span class="mi">1000</span><span class="p">},</span>
  <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">done</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">interval</span> <span class="o">=</span> <span class="nx">opts</span> <span class="o">&amp;&amp;</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">interval</span> <span class="o">||</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="nx">done</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="nx">run</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">self</span><span class="p">.</span><span class="nx">ping</span><span class="p">();</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">timer</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">interval</span><span class="p">);</span>
    <span class="nx">done</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="nx">stop</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">clearInterval</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">timer</span><span class="p">);</span>
    <span class="nx">done</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="nx">ping</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">output</span><span class="p">({</span><span class="s1">'ping'</span><span class="o">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">()});</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>

<p><code>process()</code> is called every time a message received at the Node's
input.</p>

<p>Your code needs to call <code>output()</code> whenever you have a message to send
out from the node, and must excute the <code>done</code> callback.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">straw</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'straw'</span><span class="p">);</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">straw</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">title</span><span class="o">:</span> <span class="s1">'Count'</span><span class="p">,</span>
  <span class="nx">total</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nx">process</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">done</span><span class="p">)</span> <span class="p">{</span>      
    <span class="k">this</span><span class="p">.</span><span class="nx">total</span> <span class="o">++</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">output</span><span class="p">({</span><span class="nx">count</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">total</span><span class="p">},</span> <span class="nx">done</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>

<p>Calling <code>console.log</code> from within a node will output timestamped
messages to the shell, showing you which Node they came from.</p>

<p>Run the topology like this:</p>

<pre><code>$ node examples/ping-count-print.js 
2013-07-20 10:59:17 INIT     6988 print
2013-07-20 10:59:17 STARTED  6988 print
2013-07-20 10:59:17 INIT     6985 ping
2013-07-20 10:59:17 STARTED  6985 ping
2013-07-20 10:59:17 INIT     6987 count
2013-07-20 10:59:17 STARTED  6987 count
2013-07-20 10:59:17 TOPOLOGY STARTED
2013-07-20 10:59:18 STDOUT   print                {"count":1}
2013-07-20 10:59:19 STDOUT   print                {"count":2}
2013-07-20 10:59:20 STDOUT   print                {"count":3}
</code></pre>

<p>Press <code>^C</code> to stop.</p>

<p>(Watching files is disabled for now until I can resolve <code>Error watch
EMFILE</code> being thrown. You can re-enable by changing <code>this.watch =
false;</code> to true at the top of lib/runner.js)</p>

<p>If you make any changes to a node file it's process will be terminated
and respawned. This is really handy in development. try running the
ping-count-print example, edit <code>examples/nodes/print/index.js</code> (just
add a space somewhere) then save it. You will see output in the log
letting you know it's been stopped and restarted.</p>

<p>The examples are stored in a folder named after each node, it's fine
making a folder called nodes and naming each node's file directly.
Just make sure you use an absolute path, e.g. <code>__dirname +
'./path/to/nodes/some-node.js'</code> in your Topology definition.</p>

<pre><code>nodes/my-node.js
nodes/some-node.js
</code></pre>

<h2>
<a name="topology" class="anchor" href="#topology"><span class="octicon octicon-link"></span></a>Topology</h2>

<p>Each Node must be defined in the Topology like so:</p>

<div class="highlight"><pre><span class="s1">'&lt;your-key&gt;'</span><span class="o">:</span><span class="p">{</span>
    <span class="s1">'node'</span><span class="o">:</span> <span class="s1">'&lt;absolute-path-to-node&gt;'</span><span class="p">,</span>
    <span class="s1">'input'</span><span class="o">:</span><span class="s1">'in-pipe-name'</span><span class="p">,</span>
    <span class="s1">'output'</span><span class="o">:</span><span class="s1">'out-pipe-name'</span><span class="p">,</span>
    <span class="s1">'outputs'</span><span class="o">:</span> <span class="p">{</span>
        <span class="p">[</span><span class="s1">'named-output'</span><span class="p">,</span> <span class="s1">'another-named-output'</span><span class="p">]</span>
        <span class="p">},</span>
    <span class="s1">'log'</span><span class="o">:</span> <span class="s1">'&lt;file-to-log-output-to&gt;'</span>
<span class="p">}</span>
</pre></div>

<p>To specify the location of a node relative to your topology code, use
<code>__dirname + '/where/is/my/node.js'</code>.</p>

<p><code>input</code> and <code>output</code> can either be the key of a single pipe, or an
array of pipe keys. This lets you aggregate input and branch output.
If the output field is an array, the same message will be sent to each
of them.</p>

<div class="highlight"><pre><span class="c1">// single</span>
<span class="nx">input</span><span class="o">:</span> <span class="s1">'some-pipe'</span>
<span class="nx">output</span><span class="o">:</span> <span class="s1">'that-pipe'</span>

<span class="c1">// multiple</span>
<span class="nx">input</span><span class="o">:</span> <span class="p">[</span><span class="s1">'this-pipe'</span><span class="p">,</span><span class="s1">'that-pipe'</span><span class="p">]</span>
<span class="nx">output</span><span class="o">:</span> <span class="p">[</span><span class="s1">'this-pipe'</span><span class="p">,</span><span class="s1">'that-pipe'</span><span class="p">]</span>
</pre></div>

<p><code>log</code> and <code>outputs</code> are optional. All other fields are required.</p>

<p><code>STDOUT</code> from the node (e.g. <code>console.log</code>) will be captured to the log.</p>

<p>You must define named outputs in your Topology before using them in
the node.</p>

<p>Any other fields will be passed in to the Node as options for it to
use as it sees fit.</p>

<p>You can optionally place a callback function as the last argument to
<code>straw.topology</code> that will be called once all the Nodes are up and
running.</p>

<p>topology#destroy will take down all the nodes and pipes used in the
Topology.</p>

<h3>
<a name="options" class="anchor" href="#options"><span class="octicon octicon-link"></span></a>Options</h3>

<p>You can pass options in to the Topology that will be passed in to all
node runners. These let you set the Redis host and enable StatsD. You
can add your own keys to <code>redis</code>, which is handy for things like
adding prefixes to your keys in to the Node.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">straw</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'straw'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">topo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">straw</span><span class="p">.</span><span class="nx">topology</span><span class="p">({</span>
  <span class="s1">'ping'</span><span class="o">:</span><span class="p">{</span>
    <span class="s1">'node'</span><span class="o">:</span> <span class="nx">__dirname</span> <span class="o">+</span> <span class="s1">'/nodes/ping'</span><span class="p">,</span>
    <span class="s1">'output'</span><span class="o">:</span><span class="s1">'ping-out'</span>
  <span class="p">},</span>
<span class="p">},</span> <span class="p">{</span>
  <span class="nx">pidsfile</span><span class="o">:</span> <span class="nx">__dirname</span> <span class="o">+</span> <span class="s1">'/../straw-pids.js'</span><span class="p">,</span>
  <span class="nx">redis</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">host</span><span class="o">:</span> <span class="s1">'127.0.0.1'</span><span class="p">,</span>
    <span class="nx">port</span><span class="o">:</span> <span class="mi">6379</span>
  <span class="p">},</span>
  <span class="nx">statsd</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">prefix</span><span class="o">:</span> <span class="s1">'straw'</span><span class="p">,</span>
    <span class="nx">host</span><span class="o">:</span> <span class="s1">'127.0.0.1'</span><span class="p">,</span>
    <span class="nx">port</span><span class="o">:</span> <span class="mi">8125</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>

<p>If no options or redis are provided, the default shown above will be
used.</p>

<p>If pidsfile is provided, when Straw starts a Topology it will write the
PIDs of the nodes to this file, and on next start will attempt to kill
those PIDs. This experimental feature is to try and kill Nodes left
still running after a crash.</p>

<p>If StatsD is provided, all node inputs and outputs (summed, and split
out by key) will be counted with <code>node-statsd.increment()</code>, using the
node's key as the identifier.</p>

<p>If you provide a prefix, it will be prepended to the nodes's key so
you can namespace your stats across multiple Topologies.</p>

<h2>
<a name="nodes" class="anchor" href="#nodes"><span class="octicon octicon-link"></span></a>Nodes</h2>

<p>These methods can/must be overridden depending on the required
functionality of your node;</p>

<p>The <code>done</code> calls are required.</p>

<p>In the <code>#initialize</code> method, you must use <code>process.nextTick(done)</code></p>

<div class="highlight"><pre><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">straw</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">title</span><span class="o">:</span> <span class="s1">'Human readable name'</span><span class="p">,</span>
    <span class="nx">initialize</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// process incoming options from the topology definition,</span>
        <span class="c1">// set up anything you need (e.g. database connection)</span>
        <span class="c1">// and when all finished run the done callback.</span>
        <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="nx">done</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="nx">process</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// process an incoming message. msg will be JSON.</span>

        <span class="c1">// this example just passes thru msg. normally you would do</span>
        <span class="c1">// some work on it here.</span>
        <span class="c1">// ...</span>
        <span class="c1">// and send it via the default output</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">output</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>

        <span class="c1">// or send it via a named output. The name must be configured</span>
        <span class="c1">// in your topology</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">output</span><span class="p">(</span><span class="s1">'named-output'</span><span class="p">,</span> <span class="nx">msg</span><span class="p">);</span>
        <span class="nx">done</span><span class="p">()</span>
    <span class="p">},</span>
    <span class="nx">run</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// start some background processing here e.g. fetch or</span>
        <span class="c1">// generate data</span>
        <span class="nx">done</span><span class="p">();</span>
    <span class="p">},</span>
    <span class="nx">stop</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// stop background processing. will be called when</span>
        <span class="c1">// terminating.</span>
        <span class="nx">done</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>

<h2>
<a name="pipes" class="anchor" href="#pipes"><span class="octicon octicon-link"></span></a>Pipes</h2>

<p>Pipes are implemented using Redis lists - <code>lpush</code> and <code>brpop</code>. </p>

<p>When more than one Node is connected to a given output, only one will
receive each message. This lets you easily load-balance output from a
node.</p>

<p>When a node finished processing a message it must call the <code>done</code>
callback. This signals it's ready for the next message.</p>

<p>If you want a message to go to several nodes, create multiple outputs
and connect one node to each.</p>

<p><code>examples/busy-worker.js</code> and <code>examples/busy-workers.js</code> show this in
operation.</p>

<p>If no purge flag is set or if set to true, pipes are cleared when the
Topology is started so un-processed messages from previous runs are
not consumed. To retain them across restarts set purge to false.</p>

<h3>
<a name="tap-inout" class="anchor" href="#tap-inout"><span class="octicon octicon-link"></span></a>Tap In/Out</h3>

<p>You can connect to a Topology from existing code. These Tap methods
behave the same as those you would write inside your nodes.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">tap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">straw</span><span class="p">.</span><span class="nx">tap</span><span class="p">({</span>
  <span class="s1">'input'</span><span class="o">:</span><span class="s1">'from-topology-pipe,</span>
<span class="s1">  '</span><span class="nx">output</span><span class="s1">':'</span><span class="nx">to</span><span class="o">-</span><span class="nx">topology</span><span class="o">-</span><span class="nx">pipe</span>
<span class="p">});</span>

<span class="nx">tap</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>

<span class="nx">tap</span><span class="p">..</span><span class="nx">on</span><span class="p">(</span><span class="s1">'message'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">});</span>

</pre></div>

<h3>
<a name="stats" class="anchor" href="#stats"><span class="octicon octicon-link"></span></a>Stats</h3>

<p>Nodes accumulate counts of messages emitted. You can use the count
method to count arbitrary values also.</p>

<div class="highlight"><pre><span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="p">(</span><span class="s1">'some-key'</span><span class="p">);</span>
<span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="p">(</span><span class="s1">'some-key'</span><span class="p">,</span> <span class="nx">howmany</span><span class="p">);</span>

<span class="k">this</span><span class="p">.</span><span class="nx">counts</span><span class="p">();</span> <span class="c1">// {"messages": 5, "some-key":4}</span>
<span class="k">this</span><span class="p">.</span><span class="nx">counts</span><span class="p">(</span><span class="s2">"some-key"</span><span class="p">);</span> <span class="c1">// 4</span>
</pre></div>

<h2>
<a name="installing-as-a-service" class="anchor" href="#installing-as-a-service"><span class="octicon octicon-link"></span></a>Installing as a service</h2>

<p>Once you have your Topology tested and working you'll probably want to
install it as a service.</p>

<p>Place this somewhere like <code>/etc/init/myapp.conf</code>. The path to your
node binary may be different, particularly if you are using nvm.</p>

<pre><code>#!upstart
description "My Topology"
author      "simon"

start on startup
stop on shutdown

script
    export HOME="/path/to/app"
    echo $$ &gt; /var/run/my-app.pid
    exec sudo -u sysop /usr/bin/node /path/to/app/myapp.js &gt;&gt; /var/log/app/myapp.log 2&gt;&amp;1
end script
</code></pre>

<pre><code> $ sudo service myapp start
</code></pre>

<h2>
<a name="thanks" class="anchor" href="#thanks"><span class="octicon octicon-link"></span></a>Thanks</h2>

<p>Straw takes some inspiration from
<a href="https://github.com/nathanmarz/storm">Storm</a> and
<a href="http://cycling74.com">Max/MSP</a>. It uses some code and concepts from
<a href="http://backbonejs.org">Backbone</a> for the node definitions and event
handling.</p>

<h2>
<a name="release-history" class="anchor" href="#release-history"><span class="octicon octicon-link"></span></a>Release History</h2>

<ul>
<li>14/11/2012 0.1.0 Initial release</li>
<li>15/11/2012 0.1.1 StatsD support </li>
<li>22/11/2012 0.1.2 Round-robin pipes</li>
<li>23/01/2013 0.1.3 Taps</li>
<li>31/01/2013 0.1.5 Cleaning up callback usage</li>
<li>08/04/2013 0.1.6 Added pidsfile support</li>
<li>19/07/2013 0.2.0 Removed Pubsub. Enforced callbacks.</li>
</ul><h2>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h2>

<p>Copyright (c) 2012-2013 Simon Swain<br>
Licensed under the MIT license.</p>
        </section>

        <footer>
          Straw is maintained by <a href="https://github.com/simonswain">simonswain</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

                  <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-42718447-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

      </div>
    </div>
  </body>
</html>